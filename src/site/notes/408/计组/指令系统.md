---
{"dg-publish":true,"dg-permalink":"408/计组/指令系统","permalink":"/408/计组/指令系统/","dgHomeLink":true,"dgPassFrontmatter":false}
---


# 指令格式
- 结构
	
	| 操作码字段 | 地址码字段 | 
	| ---------- | ---------- |
	- 操作码：操作性质与功能
	- 地址码：被操作信息（指令/数据）的地址
- 指令字长取决于：
	- 操作码长度
	- 操作数地址码长度
	- 操作数地址的个数
- 单/半字长指令：一/半个机器字长的指令
- 定长指令字结构/变长指令字结构
- 常为字节整数倍

- 按操作码数量分类
	- 零地址指令
		
		| OP  | 
		| --- |
		- 没有显式地址
		- 类型：
			- 不需要操作数的指令：空操作，停机指令，关中断指令
			- 零地址运算类指令：仅用于堆栈计算机，两个运算操作数从栈弹出运算，结果压回栈
	- 一地址指令
	
		| OP  | A_1  |
		| --- | --- |
		- 类型：
			- 只有目的操作数的单操作数指令
				- `OP(A_1)-> A_1`
				- 加一，减一，求反，求补
			- 隐含约定目的地址（常为ACC）的双操作数指令
				- `(ACC)OP(A_1)->ACC`
	- 二地址指令
	
		| OP  | A_1 | A_2 | 
		| --- | --- | --- |
		- 常用算数和逻辑运算
			- `(A_1)OP(A_2)->A_1`
	- 三地址指令
		
		| OP  | A_1 | A_2 | A_3 | 
		| --- | --- | --- | --- |
		- 另设目的地址
			- `(A_1)OP(A_2)->A_3`
	- 四地址指令
	
		| OP  | A_1 | A_2 | A_3 | A_4 |
		| --- | --- | --- | --- | --- |
		- 另设下一条指令地址
			- `(A_1)OP(A_2)->A_3`
			- `A_4`为下一条指令地址
	
- 定长操作码
	- 指令字最高位部分分配固定位数表示操作码
	- 简化硬件设计，提高指令译码和识别速度
- 扩展操作码
	- 可变长操作码
	- 类哈夫曼树
	- 要求：
		- 不允许短码是长码的前缀
		- 指令操作码不重复
	- 高频指令短操作码，低频指令长操作码，减少译码分析时间
- 指令操作类型
	- 数据传送：`MOV LOAD STORE`
	- 算数与逻辑运算：`ADD SUB CMP MUL DIV INC DEC AND OR NOT XOR`
	- 移位操作：算数移位`SAL SAR`，逻辑移位`SHL SHR`，循环移位`ROL ROR`
	- 转移操作：`JMP BRANCH CALL RET TRAP`
	- 输入输出操作

- 接下来的指令格式跟前面讨论的都不同
# 指令与数据寻址
- 形式地址 `A` $\rightarrow$ 有效地址 `EA`
- 指令寻址
	- 顺序寻址：`PC++`
	- 跳跃寻址：指令给出地址

## 数据寻址
- 区分不同寻址方法的指令字格式
	
	| 操作码 | 寻址特征 | 形式地址 A | 
	| ------ | -------- | ---------- |
- 隐含寻址
	- 不显式给出地址
	- 单操作码时通常另一个存ACC
	- 优点：缩短指令字长
	- 缺点：需增加存储操作数或隐含地址的硬件
- 立即数寻址
	- 优点：执行阶段不访问主存
	- 缺点：A的位数限制范围
- 间接寻址
	- 形式地址指向存有另一个地址的单元（可多次间接寻址）
		- `EA=(A)`
	- 优点：扩大寻址范围（EA比A长），便于编制程序（方便地完成子程序返回）
	- 缺点：执行阶段多次访存，速度慢，不如寄存器寻址
- 寄存器寻址
	- 指令字中给出寄存器编号
		- `EA=R_i`
	- 优点：不访问主存，只访问寄存器，寄存器地址少，码短，执行速度快，支持向量/矩阵运算
	- 缺点：贵，寄存器个数有限
- 寄存器间接寻址
	- 寄存器中存地址
		- `EA=(R_i)`
	- 优点：比一般间接寻址速度快
	- 缺点：仍要访问主存
- 相对寻址
	- PC内容加形式地址为有效地址
		- `EA=(PC)+A`
		- A用补码表示，可正可负
	- 用于转移指令
	- <mark style="background: #FF5582A6;">注意：转移指令取出后，PC自动计数，加上指令字节数（取出两字节指令+2），随后再+A跳转</mark> 
	- 优点：操作数不固定，随PC变化，便于程序浮动
- 基址寻址
	- CPU中基址寄存器BR（也可用通用寄存器）的内容加上形式地址A为有效地址
		- `EA=(BR)+A`
	- 基址寄存器
		- CPU和用户都透明
			- 但是用户可决定所用（如需要）的通用寄存器
		- 面向操作系统，内容由操作系统或管理程序决定
		- 解决程序逻辑地址空间和存储器物理空间的无关性
	- A在程序执行中不可变
	- 优点：扩大寻址范围，用户不必考虑程序在主存的位置，利于多道程序设计，便于编制浮动程序
	- 缺点：偏移量较短
- 编制寻址
	- 变址寄存器IX（也可用通用寄存器）内容加上形式地址A为有效地址
		- `EA=(IX)+A`
	- 变址寄存器
		- 面向用户
		- 执行中可由用户改变
		- 适合编制循环程序，数组处理
	- A在程序执行中可变
	- 偏移量EA位数足以表示整个存储空间
- 堆栈寻址
	- 堆栈里取数
	- 堆栈
		- 存储器或专用寄存器中的一块特定的后进先出存储区
		- 读/写单元地址由堆栈指针寄存器SP给出
		- 硬堆栈：寄存器堆栈，贵，小
		- 软堆栈：主存堆栈，便宜，大
		- 通常读/写前后伴有自动SP加减
	- 以无操作数指令表现
- 寻址方式，有效地址，访存次数
	
	| 寻址方式           | 有效地址    | 访存次数                              |
	| ------------------ | ----------- | ------------------------------------- |
	| 隐含寻址           | 程序指定    | 0（指其本身，另一个操作数不一定了就） |
	| 立即寻址           | A为操作数   | 0                                     |
	| 直接寻址           | `EA=A`      | 1                                     |
	| 一次间接寻址       | `EA=(A)`    | 2                                     |
	| 寄存器寻址         | `EA=R_i`    | 0                                     |
	| 寄存器一次间接寻址 | `EA=(R_i)`  | 1                                     |
	| 相对寻址           | `EA=(PC)+A` | 1                                     |
	| 基址寻址           | `EA=(BR)+A` | 1                                     |
	| 变址寻址           | `EA=(IX)+A` | 1                                     | 
